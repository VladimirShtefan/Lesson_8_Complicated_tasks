# Урок 8* Задачи со звездочкой

### Генерация значения на кубике

Для реализации игры создайте класс кубика. Кубик может иметь 4/6/8/10/20/100 граней.

У кубика есть метод dice_throw, который возвращает int значение (по дороге сохраняя его в поле history).

У кубика есть поле history и метод get_history(x), который возвращает x последних бросков.


Пример использования класса:

```python
dice_4 = Dice(4)

print(dice_4.dice_throw())
>> 3

print(dice_4.dice_throw())
>> 2

print(dice_4.dice_throw())
>> 4

print(dice_4.dice_throw())
>> 1

print(dice_4.get_history())
>> 3, 2, 4, 1
```

---

### Повышение уровня

У вашего персонажа, Hero появляется способность учиться на ошибках (прямо как у вас!), каждый уровень количество HP растет на 50% от прошлого значения (и округляется до последнего ноля в большую сторону: вместо 225 будет 230, вместо 501 будет 510).

Уровень

1

2

3

4

...

Здоровье

100

150

230

350

...

Уровень персонажа рассчитывается так:

для второго уровня нужно 15 единиц,

для третьего — 30,

для четвертого — 60,

для пятого — 120.

Опыт

7

15

35

60

...

Уровень

1

2

3

4

...

Создайте персонажа с полями:

- name,
- health,
- experience,
- level.

При инициализации количество опыта равно 0,

уровень рассчитывается от опыта (и должен быть равен 1),

здоровье рассчитывается от уровня (и должно быть равно 100).

Реализуйте методы:

```python
add_experience(30) — добавляет опыт, при этом уровень и здоровье пересчитываются.
get_level() – возвращает опыт, это целое число.
get_health() – возвращает здоровье, это целое число.
```

---

### Битва с бинарным драконом

Создайте класс Dragon с полями:

- color,
- health,
- is_alive.

И методами:

- bite,
- get_damage,
- get_health,
- die.

При инициализации дракон получает цвет и здоровье.

При вызове метода bite дракон кусает героя и высасывает из него 10 единиц здоровья, добавляя их к счетчику собственного здоровья.

При вызове метода get_damage(x) дракон получает x урона, однако, если x является степенью двойки, то здоровье дракона восстанавливается до ближайшей степени двойки (то есть от 200 до 256, от 100 до 128).

Показатель здоровья у дракона не может упасть ниже 0!

Когда показатель здоровья у дракона коснулся нуля, он уже не может делать bite, а поле is_alive принимает значение False.

Метод get_health возвращает показатель здоровья (health).

Пример работы программы:

```python
dragon = Dragon(“black”, 500)
dragon.get_health()
>500
dragon.get_damage(260)
dragon.get_health()
>240
dragon.get_damage(4)
dragon.get_health()
>256
dragon.bite()
>Кусь на 10
dragon.get_health()
>266
dragon.get_damage(266)
>Дракон умер
dragon.bite()
>Кусь невозможен, дракон мертв
dragon.get_health()
>0
```

---

### Ошибиться нельзя

В пути герой, как и в любом эпическом нарративе, встречает предсказателя. Допишите код так, чтобы предсказатель отвечал только на 1 вопрос.

```python
class Teller:
def __init__(self):
  self.shots = 1
def ask(self, topic):
 
  if topic == "дорога":
    return "Отправляйся на север, держись самого края леса, найдешь пещеру, пройдешь внутри, от нее 2-3 лиги до городка"
 
  elif topic == "виверна":
    return "Победить виверну можно только магическим оружием. Спроси в городке сотрудников гильдии магического метода"
 
  elif topic == "дракон":
    return "За сломанной горой в скалах живет дракон. С ним вообще никогда проблем не было"
  
  return "Ты исчерпал свои попытки, странник. Уходи!"
 
teller = Teller()
teller.ask("дорога")
teller.ask("виверна")
teller.ask("дракон")
```

---

### Заплатите чеканной монетой!

По примеру словарей и списков вы должны были догадаться, что можно вкладывать друг в друга экземпляры классов! Давайте создадим класс персонажа, у которого есть монеты! Монеты бывают разных материалов. Чтобы разобраться, сколько денег у персонажа, переведите всё в золотой эквивалент.

Функция **get_money** возвращает число золотых монет с плавающей [в расплавленном золоте] запятой.

1 золотая

1 золотая

10 серебряных

1 золотая

100 бронзовых

1 золотая
